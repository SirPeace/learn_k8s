# Components configuration

Configuration of K8s components (deployments, services, etc.) is described in the yaml files (same to docker-compose).

Usually config files are stored in the project root folder (just as docker-compose).

## Identical start

The first two lines declare the API version and a component type to configure.

```
apiVersion: <version>
kind: <component>
```

`<version>` can be:

- _apps/v1_ (for _Deployment_)
- _v1_ (for _Service_)

`<component>` can be:

- _Deployment_
- _Service_

## Logical parts

Next, the configuration file is divided into **3 logical parts**:

1. _`metadata`_ (Metadata)
2. _`spec`_ (Specification)
3. _Status_

Status is continuously generated by K8s automatically. However, statuses of components are stored not in the configuration files, but in the master nodes' _etcd_ processes. Statuses are used to track the difference between current component state and it's configuration. When you _apply_ the configuration, K8s checks if state and config differ, and if they do - updates the component state.

Attributes of `spec` are _specific_ to the _kind_ of specified component. Here you _specify_ the most of the component's configuration.

Metadata attributes are same for all components.

## Connecting components

K8s components connect to each other using **labels** and **selectors** that you specify in the configuration files. Metadata holds component's labels to identify it. Specification holds selectors to other components that configured component should reference.

Label is a _unique key-value pair_ that identifies the configured component. You can think of any, there are no restrictions.

Selectors are the _pointers_ to other components. They are also key-value pairs.

Aside from labels and selectors, the **ports** configuration is also required to connect components.

For example: Service exposes some port to connect to, but it should know ports of underlying Pods, which are the same to ones that containers expose. All these port dependencies are configurable.
